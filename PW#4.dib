#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
using System.Diagnostics;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{   

    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //

    static Barrier barrier;
    static double area;

    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {   
        area = 0.0;
        if (Math.Abs(step) < Math.Pow(10, -7))
        {
            throw new Exception("Step close to machine zero");
        }

        barrier = new Barrier(threadsnumber);
        List<Thread> listOfThreads = new List<Thread>();
        double lengthOneThread = Math.Abs(b - a) / (double)threadsnumber; 

        for(double i = 0; i < threadsnumber; i++)
        {
            double leftBorder = a + i * lengthOneThread;
            double rightBorder = leftBorder + lengthOneThread;

            Thread thread = new Thread(() => currentPartIntegralArea(leftBorder, rightBorder, function, step, ref area));
            listOfThreads.Add(thread);
        }

        foreach(Thread thread in listOfThreads)
        {
            thread.Start();
        }

        foreach(Thread thread in listOfThreads)
        {
            thread.Join();
        }

        return area;
    }

    public static void currentPartIntegralArea(double leftBorder, double rightBorder, Func<double, double> function, double step, ref double area)
    {   
        double threadArea = 0.0;
        int StepsInBetween = (int)(Math.Abs(rightBorder - leftBorder) / step);
        var x1 = leftBorder;
        var x2 = leftBorder + step;

        for(int j = 0; j < StepsInBetween; j++)
        {
            threadArea += ((function(x1) + function(x2)) / 2) * step;
            x1 += step;
            x2 += step;
        }

        if (x2 > rightBorder)
        {
            threadArea += ((function(x1) + function(x2) / 2) * (rightBorder - x1));
        }
        
        Interlocked.CompareExchange(ref area, area + threadArea, area);
        barrier.SignalAndWait();
    }
}

class TrapezoidalIntegration
{
    public static double CalculateIntegral(Func<double, double> func, double intervalStart, double intervalEnd, double dx)
    {   
        if (Math.Abs(dx) < Math.Pow(10, -7))
        {
            throw new Exception("dx близок к машинному нулю");
        }

        var x1 = intervalStart;
        var x2 = intervalStart + dx;
        double result = 0;
        int intervals = (int)((intervalEnd - intervalStart)/dx);
        
        for(int i = 0; i < intervals; i++)
        {
            double area = Math.Abs((func(x1) + func(x2))/ 2 * dx);
            x1 = dx;
            x2 = dx;
            result += area;
        }

        return result;
    }
}

#!csharp

//Выбор оптимального шага
double[] steps = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6];
Stopwatch taimer = new Stopwatch();
List<double> averageTimeList = new List<double>();
List<double> averageResultList = new List<double>();
var SIN = (double x) => Math.Sin(x);

for(int i = 0; i < steps.Length; i++)
{   
    double result = 0.0;
    double time = 0.0;
    for(int j = 0; j < 10; j++)
    {
    taimer.Restart();
    result += DefiniteIntegral.Solve(-100, 100, SIN, steps[i], 10);
    taimer.Stop();
    time += taimer.ElapsedMilliseconds;
    }
    averageResultList.Add(result / 10);
    averageTimeList.Add(time / 10);
    Console.WriteLine($"Шаг: {steps[i]}\tВремя: {averageTimeList[i]}\tРезультат: {averageResultList[i]}");
}
//Был выбран шаг 1e-4 так как он обеспечивает оптимальную производительность и точность

#!csharp

//Выбор оптимального числа потоков
#r "nuget:ScottPlot, 5.0.36"

using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(700, 700)), HtmlFormatter.MimeType);

Stopwatch taimer = new Stopwatch();
List<double> averageTimeList = new List<double>();
List<int> threadNum = new List<int>();
var SIN = (double x) => Math.Sin(x);


for(int i = 1; i <= 100; i += 10)
{   
    double result = 0.0;
    double time = 0.0;
    for(int j = 0; j < 10; j++)
    {
    taimer.Restart();
    result += DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, i);
    taimer.Stop();
    time += taimer.ElapsedMilliseconds;
    }
    averageTimeList.Add(time / 10);
    threadNum.Add(i);
}

ScottPlot.Plot graph = new();
graph.Add.Scatter(averageTimeList, threadNum);
graph
//Анализируя график, оптимальное число потоков - 41

#!csharp

//Сравнение однопоточной и многопоточной версий
Stopwatch taimer = new Stopwatch();
var SIN = (double x) => Math.Sin(x);
var totalTime1 = 0.0;
var totalTime2 = 0.0;

for(int i = 0; i < 10; i++)
{   
    taimer.Restart();
    TrapezoidalIntegration.CalculateIntegral(SIN, -100, 100, 1e-4);
    taimer.Stop();
    totalTime1 += taimer.ElapsedMilliseconds;

    taimer.Restart();
    DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, 41);
    taimer.Stop();
    totalTime2 += taimer.ElapsedMilliseconds;
}

Console.WriteLine($"Однопоточный вариант:\nВремя = {totalTime1 / 10}\n");
Console.WriteLine($"Многопоточный вариант:\nВремя = {totalTime2 / 10}");

#!markdown

Summary
1) Выбранный оптимальный шаг - 1e-4
2) Выбранное оптимальное число потоков - 41
3) Сравнение времени выполнения однопоточной и многопоточной реализации

    Однопоточный вариант:
    Время = 21

    Многопоточный вариант:
    Время = 10.9

    многопоточный вариант быстрее однопоточного на 52%

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
